creer un printf_fd pour faciliter la gestion des erreurs
ajouter un token NEWLINE qui ressemble au && mais qui s' active tout le temps meme si la derniere cmd contenait une erreur.

revoir le fonctionnement des tokens double quotes et simple quotes : un token est cree a partir de la 1re " a la " suivante ex : "A""B""C" = 3 tokens DQUOTES et '"A"'"" => 1token simple quotes("A") et 1 token DQUOTES vide
ensuite apres l' expander, on regroupe tous les tokens qui se suivaient (qui etaient colles sans espaces) pour former 1 seul argument (il faut trouver le moyen de savoir si les tokens etaient colles dans le prompt initial avant la tokenisation 
= idee ajouter une variable linked a t_token, si la variable linked est a 1 c' est que le token est colle (lie) au suivant)

ajouter dans le lexer backslash error si pas entre SQ ou DQ

verifier la position du type parenthesis dans le lexer = une parenthese ne peut jamais suivre une commande ? 
on dirait que les seules positions possibles pour une parenthese sont apres un operateur de priorite ou en debut de ligne ?

Askip : attention a l' impression de newlines lors de l' exit sur un minishell imbrique
ajouter strndup_gc dans libft.h et makefile


modifier la variable d' env '_' a chaque execution ($_ affiche le dernier argument de la derniere commande terminee hors pipe)

attention, les variables globales sont expandes dans l' entree std d' un heredoc alors qu' elles ne le sont pas dans l' affichage d' un fichier test (ne semble pas provenir du comportement de stdin (cat $TEST))

gerer l' expansion .* ==> affiche les fichiers caches
si * est le premier 

si .* et . le 1er char => affiche les fichiers caches, si *

2 cas : on commence par une * : les fichiers caches ne sont pas affiches
on commence par une chaine : les fichiers contenant toutes les sous chaines sont affiches

modifier le vrai del_one_garbage comme dans le bac a sable.
attention les wildcards dans le nom de commande ?

pour le GC revoir l' enum de maniere plus coherente avec les types TKNLIST, BINTREE, TMP